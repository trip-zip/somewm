/*
 * button.c - AwesomeWM-compatible button class implementation
 *
 * This file merges:
 * - Legacy _button.bind() global binding system (for backward compat)
 * - AwesomeWM class-based button objects (for awful.button)
 * - Button array functions from button_object.c
 */

#include "button.h"
#include "luaa.h"
#include "common/luaclass.h"
#include "common/luaobject.h"
#include "common/lualib.h"
#include "drawin.h"
#include "client.h"
#include "../somewm_api.h"
#include "../util.h"
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <linux/input-event-codes.h>

/* ========================================================================
 * AwesomeWM Class System - button class
 * ======================================================================== */

/* Button class global */
lua_class_t button_class;

/* ========================================================================
 * Button array functions - GENERATED BY ARRAY_FUNCS MACRO in button.h
 * AwesomeWM pattern: button_array_init/wipe/append/splice/take/remove
 * are all static inline functions generated by ARRAY_FUNCS macro.
 * ======================================================================== */

/* ========================================================================
 * Modifier parsing utilities
 * ======================================================================== */

/* Parse modifier string to bitmask */
static uint16_t
parse_modifier(const char *mod)
{
	if (!mod) return 0;

	if (strcasecmp(mod, "Shift") == 0) return BUTTON_MODIFIER_SHIFT;
	if (strcasecmp(mod, "Lock") == 0) return BUTTON_MODIFIER_CAPS;
	if (strcasecmp(mod, "Control") == 0 || strcasecmp(mod, "Ctrl") == 0)
		return BUTTON_MODIFIER_CTRL;
	if (strcasecmp(mod, "Mod1") == 0 || strcasecmp(mod, "Alt") == 0)
		return BUTTON_MODIFIER_ALT;
	if (strcasecmp(mod, "Mod4") == 0 || strcasecmp(mod, "Super") == 0)
		return BUTTON_MODIFIER_SUPER;
	if (strcasecmp(mod, "Mod2") == 0) return BUTTON_MODIFIER_MOD2;
	if (strcasecmp(mod, "Mod3") == 0) return BUTTON_MODIFIER_MOD3;
	if (strcasecmp(mod, "Mod5") == 0) return BUTTON_MODIFIER_MOD5;
	if (strcasecmp(mod, "Any") == 0) return BUTTON_MODIFIER_ANY;

	fprintf(stderr, "[PARSE_MODIFIER] WARNING: Unknown modifier '%s', returning 0\n", mod);
	return 0;
}

/* Convert modifiers bitmask to Lua table
 * Takes uint32_t to match wlroots modifier masks */
static void
luaA_pushmodifiers(lua_State *L, uint32_t modifiers)
{
	int idx;

	idx = 1;
	lua_newtable(L);

	if (modifiers & BUTTON_MODIFIER_SHIFT) {
		lua_pushstring(L, "Shift");
		lua_rawseti(L, -2, idx++);
	}
	if (modifiers & BUTTON_MODIFIER_CAPS) {
		lua_pushstring(L, "Lock");
		lua_rawseti(L, -2, idx++);
	}
	if (modifiers & BUTTON_MODIFIER_CTRL) {
		lua_pushstring(L, "Control");
		lua_rawseti(L, -2, idx++);
	}
	if (modifiers & BUTTON_MODIFIER_ALT) {
		lua_pushstring(L, "Mod1");
		lua_rawseti(L, -2, idx++);
	}
	if (modifiers & BUTTON_MODIFIER_SUPER) {
		lua_pushstring(L, "Mod4");
		lua_rawseti(L, -2, idx++);
	}
	if (modifiers & BUTTON_MODIFIER_MOD2) {
		lua_pushstring(L, "Mod2");
		lua_rawseti(L, -2, idx++);
	}
	if (modifiers & BUTTON_MODIFIER_MOD3) {
		lua_pushstring(L, "Mod3");
		lua_rawseti(L, -2, idx++);
	}
	if (modifiers & BUTTON_MODIFIER_MOD5) {
		lua_pushstring(L, "Mod5");
		lua_rawseti(L, -2, idx++);
	}
}

/* Parse Lua table to modifiers bitmask */
static uint16_t
luaA_tomodifiers(lua_State *L, int idx)
{
	uint16_t modifiers = 0;

	/* Handle nil or missing modifiers - return 0 (no modifiers) */
	if (lua_isnil(L, idx) || lua_isnone(L, idx))
		return 0;

	/* If not a table, return 0 instead of crashing */
	if (!lua_istable(L, idx))
		return 0;

	/* Convert negative index to absolute before modifying stack
	 * This is critical: lua_pushnil() will change the stack, making
	 * relative indices point to wrong positions */
	if (idx < 0)
		idx = lua_gettop(L) + idx + 1;

	lua_pushnil(L);
	while (lua_next(L, idx)) {
		if (lua_isstring(L, -1)) {
			modifiers |= parse_modifier(lua_tostring(L, -1));
		}
		lua_pop(L, 1);
	}

	return modifiers;
}

/* ========================================================================
 * Button array Lua conversions (AwesomeWM compatible)
 * ======================================================================== */

/** Set a button array from a Lua table
 * \param L Lua state
 * \param oidx Index of object to store items into
 * \param idx Index of Lua table
 * \param buttons Button array to fill
 */
void
luaA_button_array_set(lua_State *L, int oidx, int idx, button_array_t *buttons)
{
	int i;
	int abs_idx;
	int count = 0;
	int nested_count;

	luaL_checktype(L, idx, LUA_TTABLE);

	/* Convert relative index to absolute (stack will grow during iteration) */
	abs_idx = idx < 0 ? ((lua_gettop(L) + 1) + idx) : idx;

	/* Unref existing buttons */
	for (i = 0; i < buttons->len; i++)
		luaA_object_unref_item(L, oidx, buttons->tab[i]);

	button_array_wipe(buttons);
	button_array_init(buttons);

	/* Iterate table and collect button objects */
	lua_pushnil(L);
	while (lua_next(L, abs_idx)) {
		count++;
		/* Check if value is a button object or awful.button wrapper */
		if (lua_istable(L, -1)) {
			fprintf(stderr, "[BUTTON_ARRAY_SET] Item %d is a table, checking for _c_button or nested buttons\n", count);
			/* Try to get _c_button field (awful.button wrapper) */
			lua_getfield(L, -1, "_c_button");
			if (luaA_toudata(L, -1, &button_class)) {
				fprintf(stderr, "[BUTTON_ARRAY_SET] Found _c_button, adding to array\n");
				/* ref_item pops _c_button, leaves table on stack */
				button_array_append(buttons, luaA_object_ref_item(L, oidx, -1));
				/* Pop the table */
				lua_pop(L, 1);
			} else {
				lua_pop(L, 1); /* Pop nil _c_button */
				/* Maybe it's an array of capi.button objects - iterate it */
				nested_count = 0;
				lua_pushnil(L);
				while (lua_next(L, -2)) {
					if (luaA_toudata(L, -1, &button_class)) {
						nested_count++;
						fprintf(stderr, "[BUTTON_ARRAY_SET] Found nested capi.button #%d\n", nested_count);
						/* luaA_object_ref_item removes the item from stack */
						button_array_append(buttons, luaA_object_ref_item(L, oidx, -1));
					} else {
						lua_pop(L, 1); /* Pop non-button value */
					}
				}
				if (nested_count == 0) {
					fprintf(stderr, "[BUTTON_ARRAY_SET] Table has no buttons inside\n");
				}
				/* Pop the table after iteration */
				lua_pop(L, 1);
			}
		}
		else if (luaA_toudata(L, -1, &button_class)) {
			/* Direct button userdata */
			button_t *btn = luaA_toudata(L, -1, &button_class);
			fprintf(stderr, "[BUTTON_ARRAY_SET] Item %d is direct capi.button: btn=%u mods=0x%x\n",
			        count, btn->button, btn->modifiers);
			/* luaA_object_ref_item removes the item from stack, so don't pop after */
			button_array_append(buttons, luaA_object_ref_item(L, oidx, -1));
		}
		else {
			fprintf(stderr, "[BUTTON_ARRAY_SET] Item %d is unknown type: %s\n", count, lua_typename(L, lua_type(L, -1)));
			lua_pop(L, 1); /* Pop value - only for unknown types */
		}
	}
}

/** Push button array as Lua table
 * \param L Lua state
 * \param oidx Index of object to get items from
 * \param buttons Button array to push
 * \return Number of elements pushed on stack
 */
int
luaA_button_array_get(lua_State *L, int oidx, button_array_t *buttons)
{
	int i;

	lua_createtable(L, buttons->len, 0);
	for (i = 0; i < buttons->len; i++) {
		luaA_object_push_item(L, oidx, buttons->tab[i]);
		lua_rawseti(L, -2, i + 1);
	}
	return 1;
}

/* ========================================================================
 * Button event checking
 * ======================================================================== */

/* Convert button number (awful.button style) to event code */
static uint32_t
button_number_to_event_code(int button)
{
	switch (button) {
	case 1: return BTN_LEFT;
	case 2: return BTN_MIDDLE;
	case 3: return BTN_RIGHT;
	case 4: return 0x113;  /* BTN_SIDE / scroll up */
	case 5: return 0x114;  /* BTN_EXTRA / scroll down */
	default: return button;
	}
}

/* Check if button matches event */
static bool
button_matches(button_t *btn, uint16_t mods, uint32_t button_code)
{
	uint32_t btn_code;

	if (!btn)
		return false;

	/* Check button number (0 means any) */
	if (btn->button != 0) {
		btn_code = button_number_to_event_code(btn->button);
		if (btn_code != button_code)
			return false;
	}

	/* Check modifiers */
	if (btn->modifiers != BUTTON_MODIFIER_ANY) {
		if ((mods & 0xFF) != btn->modifiers)
			return false;
	}

	return true;
}

/** Check button array for matching button and execute callback
 * \param buttons Button array to check
 * \param modifiers Current modifier mask
 * \param button Button event code
 * \param L Lua state
 * \param drawin_idx Drawin object index on stack (for passing to callback)
 * \return true if handled, false otherwise
 */
bool
button_array_check(button_array_t *buttons, uint16_t modifiers, uint32_t button,
                   lua_State *L, int drawin_idx)
{
	int i;
	bool handled = false;

	/* Safety check for uninitialized or null array */
	if (!buttons || !buttons->tab) {
		return false;
	}

	/* Check each button in array */
	for (i = 0; i < buttons->len; i++) {
		button_t *btn = buttons->tab[i];

		if (button_matches(btn, modifiers, button)) {
			/* TODO: Call press/release callbacks via signals
			 * For now just mark as handled */
			handled = true;
			fprintf(stderr, "[BUTTON_ARRAY] Match found for button %u with mods 0x%x\n",
			        button, modifiers);
		}
	}

	return handled;
}

/* ========================================================================
 * Button property getters/setters (AwesomeWM compatible)
 * ======================================================================== */

LUA_OBJECT_EXPORT_PROPERTY(button, button_t, button, lua_pushinteger)
LUA_OBJECT_EXPORT_PROPERTY(button, button_t, modifiers, luaA_pushmodifiers)

static int
luaA_button_set_modifiers(lua_State *L, button_t *b)
{
	b->modifiers = luaA_tomodifiers(L, -1);
	luaA_object_emit_signal(L, -3, "property::modifiers", 0);
	return 0;
}

static int
luaA_button_set_button(lua_State *L, button_t *b)
{
	b->button = luaL_checkinteger(L, -1);
	luaA_object_emit_signal(L, -3, "property::button", 0);
	return 0;
}

/* ========================================================================
 * Button class allocator and constructor
 * ======================================================================== */

/** Allocator for button objects (called by class system)
 * \param L Lua state
 * \return Pointer to new button object
 */
static button_t *
button_allocator(lua_State *L)
{
	button_t *button;

	/* Create button using macro-generated button_new() */
	button = button_new(L);
	fprintf(stderr, "[BUTTON_NEW] Created button %p\n", (void*)button);

	/* Initialize with defaults */
	button->modifiers = 0;
	button->button = 0;  /* 0 = any button */

	return button;
}

/** Constructor for button class (called from Lua)
 * Usage: button({modifiers}, button_num, press_callback, release_callback)
 * \param L Lua state
 * \return Number of return values (1 = button object)
 */
static int
luaA_button_new(lua_State *L)
{
	return luaA_class_new(L, &button_class);
}

/* ========================================================================
 * Legacy button system stubs (for backward compatibility with somewm.c)
 * ======================================================================== */

/** Check if a Lua button binding matches (LEGACY - currently disabled)
 * \param mods Current modifier mask
 * \param button Button code
 * \return 0 (not handled)
 */
int
luaA_button_check(uint32_t mods, uint32_t button)
{
	/* TODO: Implement if needed for global button bindings */
	(void)mods;
	(void)button;
	return 0;
}

/* ========================================================================
 * Button event handling - AwesomeWM-compatible pattern
 * ======================================================================== */

/**
 * Translate Linux input button codes to X11-style button numbers
 * BTN_LEFT (0x110/272) -> 1
 * BTN_RIGHT (0x111/273) -> 3
 * BTN_MIDDLE (0x112/274) -> 2
 * BTN_SIDE (0x113/275) -> 8
 * BTN_EXTRA (0x114/276) -> 9
 */
static uint32_t
translate_button_code(uint32_t linux_button)
{
	switch (linux_button) {
	case 0x110: return 1;  /* BTN_LEFT */
	case 0x111: return 3;  /* BTN_RIGHT */
	case 0x112: return 2;  /* BTN_MIDDLE */
	case 0x113: return 8;  /* BTN_SIDE */
	case 0x114: return 9;  /* BTN_EXTRA */
	default:
		/* For other buttons, try to map sensibly */
		if (linux_button >= 0x110 && linux_button <= 0x11f)
			return linux_button - 0x110 + 1;
		return linux_button;  /* Pass through if not a known button */
	}
}

/** Emit button::press or button::release signal on drawable
 * This is Stage 1 of AwesomeWM's two-stage button event handling.
 * \param L Lua state
 * \param drawin Drawin object
 * \param x Relative X coordinate
 * \param y Relative Y coordinate
 * \param button Button number (Linux input code)
 * \param mods Modifier mask
 * \param is_press true for press, false for release
 */
static void
emit_drawable_button_signal(lua_State *L, drawin_t *drawin, int x, int y,
                            uint32_t button, uint32_t mods, bool is_press)
{
	const char *signal_name;
	uint32_t translated_button;

	signal_name = is_press ? "button::press" : "button::release";
	translated_button = translate_button_code(button);

	/* Push drawable from drawin's uservalue table (AwesomeWM pattern)
	 * First push drawin, then get drawable item from its uservalue */
	luaA_object_push(L, drawin);
	luaA_object_push_item(L, -1, drawin->drawable);
	lua_remove(L, -2);  /* Remove drawin, keep drawable */

	if (lua_isuserdata(L, -1)) {

		/* Call drawable:emit_signal(signal_name, x, y, button, modifiers) */
		/* Drawable has its own signal system, not part of awm_object */
		lua_getfield(L, -1, "emit_signal");
		if (lua_isfunction(L, -1)) {

			/* Push drawable as self */
			lua_pushvalue(L, -2);
			/* Push signal name */
			lua_pushstring(L, signal_name);
			/* Push signal arguments: x, y, button (translated), modifiers */
			lua_pushinteger(L, x);
			lua_pushinteger(L, y);
			lua_pushinteger(L, translated_button);  /* Use translated button code */
			luaA_pushmodifiers(L, mods);

			/* Call drawable:emit_signal(signal_name, x, y, button, modifiers) */
			/* 6 arguments total: self + signal_name + x + y + button + modifiers */
			if (lua_pcall(L, 6, 0, 0) != 0) {
				lua_pop(L, 1); /* Pop error */
			} else {
			}
		} else {
			lua_pop(L, 1); /* Pop non-function value */
		}

		/* Pop drawable */
		lua_pop(L, 1);
	} else {
		/* drawable was nil or not userdata */
		lua_pop(L, 1);
	}
}

/** Emit press/release signals on matching button objects in drawin's button array
 * This is Stage 2 of AwesomeWM's two-stage button event handling.
 * \param L Lua state
 * \param drawin Drawin object
 * \param button Button number
 * \param mods Modifier mask
 * \param is_press true for press, false for release
 * \return Number of matching buttons found
 */
static int
drawin_emit_button_signals(lua_State *L, drawin_t *drawin, uint32_t button,
                           uint32_t mods, bool is_press)
{
	const char *signal_name;
	uint32_t translated_button;
	uint16_t masked_mods;
	int matched;
	int i;
	button_t *btn;
	bool btn_matches;
	bool mods_match;

	signal_name = is_press ? "press" : "release";
	translated_button = translate_button_code(button);
	matched = 0;

	/* Mask modifiers to only the bits we care about (matches old button_matches() logic) */
	masked_mods = mods & 0xFF;

	fprintf(stderr, "[BUTTON_ARRAY] Checking %d buttons for button=%u (translated=%u) mods=0x%x (masked=0x%x)\n",
	        drawin->buttons.len, button, translated_button, mods, masked_mods);

	/* Iterate through button array */
	for (i = 0; i < drawin->buttons.len; i++) {
		btn = drawin->buttons.tab[i];

		fprintf(stderr, "[BUTTON_ARRAY] Button %d: button=%u modifiers=0x%x (checking against button=%u mods=0x%x)\n",
		        i, btn->button, btn->modifiers, translated_button, masked_mods);

		/* Match button number (0 = any button) - use translated button code */
		btn_matches = (btn->button == 0 || btn->button == translated_button);

		/* Match modifiers (BUTTON_MODIFIER_ANY = any modifiers, otherwise exact match)
		 * This matches AwesomeWM's logic: modifiers == 0 means "NO modifiers", not "any modifiers" */
		mods_match = (btn->modifiers == BUTTON_MODIFIER_ANY || btn->modifiers == masked_mods);

		if (btn_matches && mods_match) {
			fprintf(stderr, "[BUTTON_ARRAY] Button %d MATCHED (btn->button=%u btn->modifiers=0x%x)\n",
			        i, btn->button, btn->modifiers);

			/* Push button object */
			luaA_object_push(L, btn);

			/* Emit press/release signal on button object (no args) */
			luaA_awm_object_emit_signal(L, -1, signal_name, 0);

			/* Pop button object */
			lua_pop(L, 1);

			matched++;
		}
	}

	fprintf(stderr, "[BUTTON_ARRAY] Matched %d buttons\n", matched);
	return matched;
}

/** Check drawin button array from C code (AwesomeWM-compatible implementation)
 * This implements the two-stage button event handling pattern from AwesomeWM:
 * Stage 1: Emit button::press/release on drawable with coordinates
 * Stage 2: Emit press/release on matching button objects
 *
 * \param drawin_ptr Drawin pointer
 * \param x Relative X coordinate (drawin-relative)
 * \param y Relative Y coordinate (drawin-relative)
 * \param button Button code
 * \param mods Modifier mask
 * \param is_press true for button press, false for release
 * \return 1 if handled, 0 otherwise
 */
int
luaA_drawin_button_check(void *drawin_ptr, int x, int y, uint32_t button,
                         uint32_t mods, bool is_press)
{
	drawin_t *drawin;
	lua_State *L;
	int matched;

	drawin = (drawin_t *)drawin_ptr;
	L = globalconf_get_lua_State();

	if (!drawin) {
		return 0;
	}

	/* Push drawin object to stack */
	luaA_object_push(L, drawin);

	/* Stage 1: Emit button::press/release on drawable */
	emit_drawable_button_signal(L, drawin, x, y, button, mods, is_press);

	/* Stage 2: Check button array and emit signals on matching button objects */
	matched = drawin_emit_button_signals(L, drawin, button, mods, is_press);

	/* Pop drawin */
	lua_pop(L, 1);

	/* Return 1 if any button matched (event was handled) */
	return (matched > 0) ? 1 : 0;
}

/** Public API: Emit button signals on a drawable (for titlebars)
 * \param client_ptr Client pointer (client_t*) - needed to access titlebar drawable
 * \param drawable_ptr Drawable pointer (drawable_t*)
 * \param x Relative X coordinate
 * \param y Relative Y coordinate
 * \param button Button number
 * \param mods Modifier mask
 * \param is_press true for press, false for release
 */
void
luaA_drawable_button_emit(void *client_ptr, void *drawable_ptr, int x, int y,
                          uint32_t button, uint32_t mods, bool is_press)
{
	client_t *client = (client_t *)client_ptr;
	drawable_t *drawable = (drawable_t *)drawable_ptr;
	lua_State *L = globalconf_get_lua_State();
	const char *signal_name;
	uint32_t translated_button;

	if (!client || !drawable) {
		return;
	}

	signal_name = is_press ? "button::press" : "button::release";
	translated_button = translate_button_code(button);

	/* Push client first (matches AwesomeWM event.c:260 pattern) */
	luaA_object_push(L, client);

	/* Push drawable from client's environment table (NOT global registry!)
	 * This matches AwesomeWM event.c:260: luaA_object_push_item(L, -1, d)
	 * Titlebar drawables are stored in client's environment via luaA_object_ref_item */
	luaA_object_push_item(L, -1, drawable);

	/* Push signal arguments: x, y, button, modifiers */
	lua_pushinteger(L, x);
	lua_pushinteger(L, y);
	lua_pushinteger(L, translated_button);
	luaA_pushmodifiers(L, mods);

	/* Emit signal using AwesomeWM's object signal system
	 * Stack: client, drawable, x, y, button, modifiers
	 * Position -5 is the drawable object (after pushing 4 args) */
	luaA_object_emit_signal(L, -5, signal_name, 4);

	/* Pop drawable and client */
	lua_pop(L, 2);
}

/** Emit button signals on client's button array
 * Similar to drawin_emit_button_signals but for clients
 *
 * \param L Lua state
 * \param c Client object
 * \param button Button code (raw wlroots code)
 * \param mods Modifier mask
 * \param is_press true for press, false for release
 * \return Number of matching buttons found
 */
static int
client_emit_button_signals(lua_State *L, int client_idx, client_t *c, uint32_t button,
                           uint32_t mods, bool is_press)
{
	const char *signal_name;
	uint32_t translated_button;
	uint16_t masked_mods;
	int matched;
	int i;
	int abs_client_idx;
	button_t *btn;
	bool btn_matches;
	bool mods_match;

	signal_name = is_press ? "press" : "release";
	translated_button = translate_button_code(button);
	matched = 0;

	/* Convert to absolute index since stack will change */
	abs_client_idx = luaA_absindex(L, client_idx);

	/* Mask modifiers to only the bits we care about */
	masked_mods = mods & 0xFF;

	/* Iterate through button array */
	fprintf(stderr, "[BUTTON_MATCH] Checking %d buttons for match (button=%u mods=0x%x signal=%s)\n",
	        c->buttons.len, translated_button, masked_mods, signal_name);

	for (i = 0; i < c->buttons.len; i++) {
		btn = c->buttons.tab[i];

		/* Match button number (0 = any button) - use translated button code */
		btn_matches = (btn->button == 0 || btn->button == translated_button);

		/* Match modifiers (BUTTON_MODIFIER_ANY = any modifiers, otherwise exact match) */
		mods_match = (btn->modifiers == BUTTON_MODIFIER_ANY || btn->modifiers == masked_mods);

		fprintf(stderr, "[BUTTON_MATCH] Button[%d]: btn->button=%u btn->mods=0x%x match=%s\n",
		        i, btn->button, btn->modifiers,
		        (btn_matches && mods_match) ? "YES" : "NO");

		if (btn_matches && mods_match) {
			fprintf(stderr, "[BUTTON_MATCH] MATCHED! Emitting '%s' signal on button object\n", signal_name);
			fprintf(stderr, "[BUTTON_PUSH] Pushing button[%d] btn=%p button=%u mods=0x%x\n",
			        i, (void*)btn, btn->button, btn->modifiers);

			/* Push button object from client's uservalue table */
			luaA_object_push_item(L, abs_client_idx, btn);

			/* Push client as first argument to the callback
			 * The awful.button wrapper does: function(_, ...) value(...) end
			 * where _ is the button object and ... should include the client
			 * so the user's callback receives (client) as expected
			 */
			lua_pushvalue(L, abs_client_idx);

			/* Emit press/release signal on button object with client as argument */
			luaA_awm_object_emit_signal(L, -2, signal_name, 1);

			/* Pop button object (argument was consumed by emit_signal) */
			lua_pop(L, 1);

			matched++;
			fprintf(stderr, "[BUTTON_MATCH] Signal emitted successfully (matched count: %d)\n", matched);
		}
	}

	fprintf(stderr, "[BUTTON_MATCH] Total matched: %d\n", matched);
	return matched;
}

/** Check client button array from C code (AwesomeWM-compatible implementation)
 * This implements the two-stage button event handling pattern from AwesomeWM:
 * Stage 1: Emit button::press/release on client object with coordinates
 * Stage 2: Emit press/release on matching button objects in client's buttons array
 *
 * \param client_ptr Client pointer (client_t*)
 * \param x Relative X coordinate (client-relative)
 * \param y Relative Y coordinate (client-relative)
 * \param button Button code (raw wlroots code)
 * \param mods Modifier mask
 * \param is_press true for button press, false for release
 * \return 1 if handled (any button matched), 0 otherwise
 */
int
luaA_client_button_check(void *client_ptr, int x, int y, uint32_t button,
                         uint32_t mods, bool is_press)
{
	client_t *c;
	lua_State *L;
	const char *signal_name;
	uint32_t translated_button;
	int matched;

	c = (client_t *)client_ptr;
	L = globalconf_get_lua_State();

	if (!c) {
		return 0;
	}

	signal_name = is_press ? "button::press" : "button::release";
	translated_button = translate_button_code(button);

	fprintf(stderr, "\n[CLIENT_BUTTON] ==========================================\n");
	fprintf(stderr, "[CLIENT_BUTTON] Button %s on client: x=%d y=%d button=%u->%u mods=0x%x\n",
	        is_press ? "PRESS" : "RELEASE", x, y, button, translated_button, mods);
	fprintf(stderr, "[CLIENT_BUTTON] Client buttons array: len=%d\n", c->buttons.len);

	/* Push client object to stack */
	luaA_object_push(L, c);

	/* Stage 1: Emit button::press/release on client with coordinates
	 * Arguments: x, y, button, modifiers (matching AwesomeWM's pattern)
	 */
	fprintf(stderr, "[CLIENT_BUTTON] Stage 1: Emitting '%s' signal on client\n", signal_name);
	lua_pushinteger(L, x);
	lua_pushinteger(L, y);
	lua_pushinteger(L, translated_button);
	luaA_pushmodifiers(L, mods);
	luaA_object_emit_signal(L, -5, signal_name, 4);
	fprintf(stderr, "[CLIENT_BUTTON] Stage 1 complete\n");

	/* Stage 2: Check button array and emit signals on matching button objects
	 * Client is at -1 on stack after emit_signal consumed the 4 arguments
	 */
	fprintf(stderr, "[CLIENT_BUTTON] Stage 2: Checking button array for matches\n");
	matched = client_emit_button_signals(L, -1, c, button, mods, is_press);
	fprintf(stderr, "[CLIENT_BUTTON] Stage 2 complete: matched=%d\n", matched);

	/* Pop client */
	lua_pop(L, 1);

	fprintf(stderr, "[CLIENT_BUTTON] ==========================================\n\n");

	/* Return 1 if any button matched (event was handled) */
	return (matched > 0) ? 1 : 0;
}

/* ========================================================================
 * Button class setup (AwesomeWM class system)
 * ======================================================================== */

/** Setup button class using AwesomeWM class system
 * \param L Lua state
 */
void
button_class_setup(lua_State *L)
{
	static const struct luaL_Reg button_methods[] =
	{
		LUA_CLASS_METHODS(button)
		{ "__call", luaA_button_new },
		{ NULL, NULL }
	};

	static const struct luaL_Reg button_meta[] =
	{
		LUA_OBJECT_META(button)
		LUA_CLASS_META
		{ NULL, NULL }
	};

	fprintf(stderr, "\n[BUTTON_CLASS_SETUP] ========================================\n");
	fprintf(stderr, "[BUTTON_CLASS_SETUP] Setting up button class with luaA_class_setup()\n");

	/* Setup button class using AwesomeWM's class infrastructure */
	luaA_class_setup(L, &button_class, "button",
	                 NULL,  /* No parent class */
	                 (lua_class_allocator_t) button_allocator,
	                 NULL,  /* No collector function */
	                 NULL,  /* No checker function */
	                 NULL,  /* Property getter fallback - will add later */
	                 NULL,  /* Property setter fallback - will add later */
	                 button_methods,  /* Class-level methods */
	                 button_meta);    /* Instance metatable methods */

	/* Add properties */
	luaA_class_add_property(&button_class, "button",
	                        (lua_class_propfunc_t) luaA_button_set_button,
	                        (lua_class_propfunc_t) luaA_button_get_button,
	                        (lua_class_propfunc_t) luaA_button_set_button);
	luaA_class_add_property(&button_class, "modifiers",
	                        (lua_class_propfunc_t) luaA_button_set_modifiers,
	                        (lua_class_propfunc_t) luaA_button_get_modifiers,
	                        (lua_class_propfunc_t) luaA_button_set_modifiers);

	fprintf(stderr, "[BUTTON_CLASS_SETUP] Class setup complete!\n");
	fprintf(stderr, "[BUTTON_CLASS_SETUP] - Class table created with class methods\n");
	fprintf(stderr, "[BUTTON_CLASS_SETUP] - Properties registered: button, modifiers\n");
	fprintf(stderr, "[BUTTON_CLASS_SETUP] - Allocator: button_allocator()\n");
	fprintf(stderr, "[BUTTON_CLASS_SETUP] ========================================\n\n");
}
