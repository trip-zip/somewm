/*
 * layer_surface.c - Layer shell surface object for Lua
 *
 * This module exposes layer shell surfaces (panels, launchers, lock screens)
 * to Lua with a signal/permission model matching AwesomeWM's client pattern.
 */

#include <wlr/types/wlr_layer_shell_v1.h>

#include "globalconf.h"
#include "layer_surface.h"
#include "objects/screen.h"
#include "objects/button.h"
#include "objects/signal.h"
#include "common/luaclass.h"
#include "common/luaobject.h"
#include "somewm_api.h"

/* Layer surface class (global) */
lua_class_t layer_surface_class;

/* Array functions generated by ARRAY_FUNCS in layer_surface.h */

/* Forward declarations */
static layer_surface_t *layer_surface_allocator(lua_State *L);
static void layer_surface_wipe(layer_surface_t *ls);

/*
 * Helper functions for string conversions
 */

const char *
layer_surface_layer_name(uint32_t layer)
{
	switch (layer) {
	case ZWLR_LAYER_SHELL_V1_LAYER_BACKGROUND:
		return "background";
	case ZWLR_LAYER_SHELL_V1_LAYER_BOTTOM:
		return "bottom";
	case ZWLR_LAYER_SHELL_V1_LAYER_TOP:
		return "top";
	case ZWLR_LAYER_SHELL_V1_LAYER_OVERLAY:
		return "overlay";
	default:
		return "unknown";
	}
}

const char *
layer_surface_keyboard_mode_name(uint32_t mode)
{
	switch (mode) {
	case ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_NONE:
		return "none";
	case ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_EXCLUSIVE:
		return "exclusive";
	case ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_ON_DEMAND:
		return "on_demand";
	default:
		return "unknown";
	}
}

/*
 * Property getters
 */

static int
luaA_layer_surface_get_namespace(lua_State *L, layer_surface_t *ls)
{
	if (ls->ls && ls->ls->layer_surface && ls->ls->layer_surface->namespace) {
		lua_pushstring(L, ls->ls->layer_surface->namespace);
	} else {
		lua_pushnil(L);
	}
	return 1;
}

static int
luaA_layer_surface_get_layer(lua_State *L, layer_surface_t *ls)
{
	if (ls->ls && ls->ls->layer_surface) {
		lua_pushstring(L, layer_surface_layer_name(ls->ls->layer_surface->current.layer));
	} else {
		lua_pushnil(L);
	}
	return 1;
}

static int
luaA_layer_surface_get_keyboard_interactive(lua_State *L, layer_surface_t *ls)
{
	if (ls->ls && ls->ls->layer_surface) {
		lua_pushstring(L, layer_surface_keyboard_mode_name(
			ls->ls->layer_surface->current.keyboard_interactive));
	} else {
		lua_pushnil(L);
	}
	return 1;
}

static int
luaA_layer_surface_get_exclusive_zone(lua_State *L, layer_surface_t *ls)
{
	if (ls->ls && ls->ls->layer_surface) {
		lua_pushinteger(L, ls->ls->layer_surface->current.exclusive_zone);
	} else {
		lua_pushinteger(L, 0);
	}
	return 1;
}

static int
luaA_layer_surface_get_anchor(lua_State *L, layer_surface_t *ls)
{
	lua_newtable(L);
	if (ls->ls && ls->ls->layer_surface) {
		uint32_t anchor = ls->ls->layer_surface->current.anchor;
		lua_pushboolean(L, anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_TOP);
		lua_setfield(L, -2, "top");
		lua_pushboolean(L, anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM);
		lua_setfield(L, -2, "bottom");
		lua_pushboolean(L, anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);
		lua_setfield(L, -2, "left");
		lua_pushboolean(L, anchor & ZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT);
		lua_setfield(L, -2, "right");
	}
	return 1;
}

static int
luaA_layer_surface_get_margin(lua_State *L, layer_surface_t *ls)
{
	lua_newtable(L);
	if (ls->ls && ls->ls->layer_surface) {
		lua_pushinteger(L, ls->ls->layer_surface->current.margin.top);
		lua_setfield(L, -2, "top");
		lua_pushinteger(L, ls->ls->layer_surface->current.margin.bottom);
		lua_setfield(L, -2, "bottom");
		lua_pushinteger(L, ls->ls->layer_surface->current.margin.left);
		lua_setfield(L, -2, "left");
		lua_pushinteger(L, ls->ls->layer_surface->current.margin.right);
		lua_setfield(L, -2, "right");
	}
	return 1;
}

static int
luaA_layer_surface_get_geometry(lua_State *L, layer_surface_t *ls)
{
	lua_newtable(L);
	if (ls->ls && ls->ls->scene_layer) {
		/* Get actual geometry from scene layer */
		lua_pushinteger(L, ls->ls->scene->node.x);
		lua_setfield(L, -2, "x");
		lua_pushinteger(L, ls->ls->scene->node.y);
		lua_setfield(L, -2, "y");
		lua_pushinteger(L, ls->ls->layer_surface->current.actual_width);
		lua_setfield(L, -2, "width");
		lua_pushinteger(L, ls->ls->layer_surface->current.actual_height);
		lua_setfield(L, -2, "height");
	}
	return 1;
}

static int
luaA_layer_surface_get_screen(lua_State *L, layer_surface_t *ls)
{
	if (ls->screen) {
		luaA_object_push(L, ls->screen);
	} else {
		lua_pushnil(L);
	}
	return 1;
}

static int
luaA_layer_surface_get_mapped(lua_State *L, layer_surface_t *ls)
{
	lua_pushboolean(L, ls->ls && ls->ls->mapped);
	return 1;
}

static int
luaA_layer_surface_get_pid(lua_State *L, layer_surface_t *ls)
{
	if (ls->ls && ls->ls->layer_surface && ls->ls->layer_surface->surface) {
		pid_t pid;
		struct wl_client *client = wl_resource_get_client(ls->ls->layer_surface->surface->resource);
		wl_client_get_credentials(client, &pid, NULL, NULL);
		lua_pushinteger(L, pid);
	} else {
		lua_pushinteger(L, 0);
	}
	return 1;
}

/*
 * has_keyboard_focus property getter/setter
 */

static int
luaA_layer_surface_get_has_keyboard_focus(lua_State *L, layer_surface_t *ls)
{
	lua_pushboolean(L, ls->has_keyboard_focus);
	return 1;
}

static int
luaA_layer_surface_set_has_keyboard_focus(lua_State *L, layer_surface_t *ls)
{
	bool focus = lua_toboolean(L, -1);
	if (focus != ls->has_keyboard_focus) {
		ls->has_keyboard_focus = focus;
		if (focus) {
			layer_surface_focus(ls);
		} else {
			layer_surface_unfocus(ls);
		}
		luaA_object_emit_signal(L, -3, "property::has_keyboard_focus", 0);
	}
	return 0;
}

/*
 * focusable property (read-only, derived from keyboard_interactive)
 */

static int
luaA_layer_surface_get_focusable(lua_State *L, layer_surface_t *ls)
{
	if (ls->ls && ls->ls->layer_surface) {
		/* Focusable if keyboard_interactive is not "none" */
		lua_pushboolean(L, ls->ls->layer_surface->current.keyboard_interactive !=
			ZWLR_LAYER_SURFACE_V1_KEYBOARD_INTERACTIVITY_NONE);
	} else {
		lua_pushboolean(L, false);
	}
	return 1;
}

/*
 * Class methods
 */

/** Get all layer surfaces.
 * @treturn table A table of layer_surface objects.
 * @staticfct get
 */
int
luaA_layer_surface_get(lua_State *L)
{
	lua_newtable(L);
	int idx = 1;
	for (int i = 0; i < globalconf.layer_surfaces.len; i++) {
		luaA_object_push(L, globalconf.layer_surfaces.tab[i]);
		lua_rawseti(L, -2, idx++);
	}
	return 1;
}

/*
 * Instance methods
 */

static int
luaA_layer_surface_tostring(lua_State *L)
{
	layer_surface_t *ls = luaA_checklayer_surface(L, 1);
	const char *ns = "unknown";
	if (ls->ls && ls->ls->layer_surface && ls->ls->layer_surface->namespace) {
		ns = ls->ls->layer_surface->namespace;
	}
	lua_pushfstring(L, "[layer_surface %s udata(%p)]", ns, (void *)ls);
	return 1;
}

static int
luaA_layer_surface_gc(lua_State *L)
{
	layer_surface_t *ls = luaA_tolayer_surface(L, 1);
	if (ls) {
		/* Clean up signals */
		signal_array_wipe(&ls->signals);

		/* Wipe button array */
		button_array_wipe(&ls->buttons);

		layer_surface_wipe(ls);
	}
	return 0;
}

/*
 * Checker function for valid property
 */

static bool
layer_surface_checker(layer_surface_t *ls)
{
	/* Layer surface is valid if the C-level struct still exists */
	return ls && ls->ls != NULL;
}

/*
 * Allocator and wipe functions
 */

static layer_surface_t *
layer_surface_allocator(lua_State *L)
{
	layer_surface_t *ls = layer_surface_new(L);

	/* Initialize with defaults */
	ls->ls = NULL;
	ls->has_keyboard_focus = false;
	ls->screen = NULL;

	/* Initialize WINDOW_OBJECT_HEADER fields */
	ls->window = 0;
	ls->frame_window = 0;
	ls->opacity = -1.0;
	ls->strut.left = 0;
	ls->strut.right = 0;
	ls->strut.top = 0;
	ls->strut.bottom = 0;
	ls->border_need_update = false;
	ls->border_width = 0;
	ls->type = WINDOW_TYPE_DOCK;  /* Layer surfaces are dock-like */
	button_array_init(&ls->buttons);

	return ls;
}

static void
layer_surface_wipe(layer_surface_t *ls)
{
	if (!ls)
		return;

	/* Clear the back-reference from LayerSurface to Lua object */
	if (ls->ls) {
		ls->ls->lua_object = NULL;
	}

	/* Clean up button array */
	button_array_wipe(&ls->buttons);

	ls->ls = NULL;
	ls->screen = NULL;
}

/*
 * Create and manage a layer surface
 */

layer_surface_t *
layer_surface_manage(lua_State *L, LayerSurface *c_ls)
{
	/* Create the Lua object using the class allocator */
	layer_surface_t *ls = layer_surface_allocator(L);

	/* Link to C-level LayerSurface */
	ls->ls = c_ls;
	c_ls->lua_object = ls;

	/* Set screen from monitor */
	if (c_ls->mon) {
		/* Find screen_t for this monitor */
		for (int i = 0; i < globalconf.screens.len; i++) {
			screen_t *s = globalconf.screens.tab[i];
			if (s && s->monitor && s->monitor->wlr_output == c_ls->mon->wlr_output) {
				ls->screen = s;
				break;
			}
		}
	}

	/* Add to global array */
	luaA_object_ref(L, -1);  /* Create reference to keep object alive */
	layer_surface_array_push(&globalconf.layer_surfaces, ls);

	/* Emit class list signal */
	luaA_class_emit_signal(L, &layer_surface_class, "list", 0);

	return ls;
}

/*
 * Signal emission functions
 */

void
layer_surface_emit_manage(layer_surface_t *ls)
{
	lua_State *L = globalconf_get_lua_State();
	luaA_object_push(L, ls);

	/* Push context and hints */
	lua_pushliteral(L, "new");
	lua_newtable(L);

	luaA_object_emit_signal(L, -3, "request::manage", 2);
	lua_pop(L, 1);  /* Pop layer_surface */
}

void
layer_surface_emit_request_keyboard(layer_surface_t *ls, const char *context)
{
	lua_State *L = globalconf_get_lua_State();
	luaA_object_push(L, ls);

	/* Push context and hints */
	lua_pushstring(L, context);
	lua_newtable(L);

	luaA_object_emit_signal(L, -3, "request::keyboard", 2);
	lua_pop(L, 1);  /* Pop layer_surface */
}

void
layer_surface_emit_unmanage(layer_surface_t *ls)
{
	lua_State *L = globalconf_get_lua_State();
	luaA_object_push(L, ls);

	/* Push context and hints */
	lua_pushliteral(L, "destroyed");
	lua_newtable(L);

	luaA_object_emit_signal(L, -3, "request::unmanage", 2);

	lua_pop(L, 1);  /* Pop layer_surface */

	/* Clear the back-reference BEFORE the C struct is freed.
	 * This prevents use-after-free in layer_surface_wipe when GC runs later. */
	if (ls->ls) {
		ls->ls->lua_object = NULL;
		ls->ls = NULL;
	}

	/* Remove from global array */
	for (int i = 0; i < globalconf.layer_surfaces.len; i++) {
		if (globalconf.layer_surfaces.tab[i] == ls) {
			layer_surface_array_take(&globalconf.layer_surfaces, i);
			luaA_object_unref(L, ls);  /* Release the reference */
			break;
		}
	}

	/* Emit class list signal */
	luaA_class_emit_signal(L, &layer_surface_class, "list", 0);
}

/*
 * Focus management
 *
 * These functions are implemented in somewm_api.c where they have access to
 * the seat and focus state. Declarations are in somewm_api.h.
 */

void
layer_surface_focus(layer_surface_t *ls)
{
	if (ls->ls) {
		layer_surface_grant_keyboard(ls->ls);
	}
}

void
layer_surface_unfocus(layer_surface_t *ls)
{
	if (ls->ls) {
		layer_surface_revoke_keyboard(ls->ls);
	}
}

/*
 * Refresh (placeholder for main loop integration)
 */

void
layer_surface_refresh(void)
{
	/* Currently nothing to do - layer surfaces are managed by wlroots */
}

/*
 * Class setup
 */

/** Constructor - layer surfaces are not user-creatable */
static int
luaA_layer_surface_new(lua_State *L)
{
	return luaL_error(L, "layer_surface objects cannot be created directly");
}

/* Class methods */
static const luaL_Reg layer_surface_methods[] = {
	LUA_CLASS_METHODS(layer_surface)
	{ "get", luaA_layer_surface_get },
	{ "__call", luaA_layer_surface_new },
	{ NULL, NULL }
};

/* Instance metatable methods */
static const luaL_Reg layer_surface_meta[] = {
	LUA_OBJECT_META(layer_surface)
	LUA_CLASS_META
	{ "__tostring", luaA_layer_surface_tostring },
	{ "__gc", luaA_layer_surface_gc },
	{ NULL, NULL }
};

void
layer_surface_class_setup(lua_State *L)
{
	/* Setup layer_surface class using AwesomeWM's class infrastructure */
	luaA_class_setup(L, &layer_surface_class, "layer_surface",
	                 NULL,  /* No parent class */
	                 (lua_class_allocator_t) layer_surface_allocator,
	                 (lua_class_collector_t) layer_surface_wipe,
	                 (lua_class_checker_t) layer_surface_checker,
	                 NULL,  /* No property getter fallback */
	                 NULL,  /* No property setter fallback */
	                 layer_surface_methods,
	                 layer_surface_meta);

	/* Register properties (read-only from protocol) */
	luaA_class_add_property(&layer_surface_class, "namespace",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_namespace,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "layer",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_layer,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "keyboard_interactive",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_keyboard_interactive,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "exclusive_zone",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_exclusive_zone,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "anchor",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_anchor,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "margin",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_margin,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "geometry",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_geometry,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "screen",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_screen,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "mapped",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_mapped,
	                        NULL);
	luaA_class_add_property(&layer_surface_class, "pid",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_pid,
	                        NULL);

	/* Register compositor-controlled properties */
	luaA_class_add_property(&layer_surface_class, "has_keyboard_focus",
	                        (lua_class_propfunc_t) luaA_layer_surface_set_has_keyboard_focus,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_has_keyboard_focus,
	                        (lua_class_propfunc_t) luaA_layer_surface_set_has_keyboard_focus);

	/* Register derived properties (read-only) */
	luaA_class_add_property(&layer_surface_class, "focusable",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_layer_surface_get_focusable,
	                        NULL);

	/* Set up capi.layer_surface */
	lua_getglobal(L, "capi");
	if (lua_isnil(L, -1)) {
		lua_pop(L, 1);
		lua_newtable(L);
		lua_pushvalue(L, -1);
		lua_setglobal(L, "capi");
	}

	lua_getglobal(L, "layer_surface");
	lua_setfield(L, -2, "layer_surface");
	lua_pop(L, 1);  /* Pop capi table */
}
