/*
 * key.c - Keybinding object
 *
 * Copyright © 2024 somewm contributors
 * Based on AwesomeWM's objects/key.c
 * Copyright © 2008-2009 Julien Danjou <julien@danjou.info>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#include "key.h"
#include "common/luaclass.h"
#include "common/luaobject.h"
#include "common/lualib.h"
#include "screen.h"
#include "signal.h"
#include "luaa.h"
#include "common/util.h"
#include "../globalconf.h"
#include <xkbcommon/xkbcommon.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

/* Manual array implementations to avoid macro pointer type issues */
void key_array_init(key_array_t *arr) {
	arr->tab = NULL;
	arr->len = 0;
	arr->size = 0;
}

void key_array_wipe(key_array_t *arr) {
	free(arr->tab);
	arr->tab = NULL;
	arr->len = 0;
	arr->size = 0;
}

void key_array_append(key_array_t *arr, keyb_t *elem) {
	if (arr->len >= arr->size) {
		arr->size = arr->size ? arr->size * 2 : 4;
		arr->tab = realloc(arr->tab, arr->size * sizeof(keyb_t *));
	}
	arr->tab[arr->len++] = elem;
}

/** Set key array from Lua table (AwesomeWM pattern)
 * Ported from AwesomeWM objects/key.c:luaA_key_array_set
 * \param L Lua state
 * \param oidx Owner object index on stack
 * \param idx Key table index on stack
 * \param keys Array to fill
 */
void
luaA_key_array_set(lua_State *L, int oidx, int idx, key_array_t *keys)
{
	luaA_checktable(L, idx);

	/* Unref all existing key objects */
	for (int i = 0; i < keys->len; i++)
		luaA_object_unref_item(L, oidx, keys->tab[i]);

	/* Clear and reinitialize the array */
	key_array_wipe(keys);
	key_array_init(keys);

	/* Iterate through table and add key objects */
	lua_pushnil(L);
	while (lua_next(L, idx)) {
		if (luaA_toudata(L, -1, &key_class))
			key_array_append(keys, luaA_object_ref_item(L, oidx, -1));
		else
			lua_pop(L, 1);
	}
}

/** Push key array as Lua table (AwesomeWM pattern)
 * Ported from AwesomeWM objects/key.c:luaA_key_array_get
 * \param L Lua state
 * \param oidx Owner object index on stack
 * \param keys Array to push
 * \return Number of values pushed (1)
 */
int
luaA_key_array_get(lua_State *L, int oidx, key_array_t *keys)
{
	lua_createtable(L, keys->len, 0);
	for (int i = 0; i < keys->len; i++) {
		luaA_object_push_item(L, oidx, keys->tab[i]);
		lua_rawseti(L, -2, i + 1);
	}
	return 1;
}

/* Setup key object class */
lua_class_t key_class;

/** Modifier name to wlroots modifier mapping */
static const struct {
	const char *name;
	uint16_t mod;
} mod_names[] = {
	{ "Shift",   (1 << 0) },  /* WLR_MODIFIER_SHIFT */
	{ "Lock",    (1 << 1) },  /* WLR_MODIFIER_CAPS */
	{ "Control", (1 << 2) },  /* WLR_MODIFIER_CTRL */
	{ "Ctrl",    (1 << 2) },  /* Alias */
	{ "Mod1",    (1 << 3) },  /* WLR_MODIFIER_ALT */
	{ "Mod2",    (1 << 4) },  /* WLR_MODIFIER_MOD2 */
	{ "Mod3",    (1 << 5) },  /* WLR_MODIFIER_MOD3 */
	{ "Mod4",    (1 << 6) },  /* WLR_MODIFIER_LOGO */
	{ "Mod5",    (1 << 7) },  /* WLR_MODIFIER_MOD5 */
	{ "Any",     0xFFFF },    /* Match any modifiers */
};

/** Parse modifier string to bitmask value
 * \param mod Modifier name
 * \return Modifier bit, or 0 if not found
 */
static uint16_t
parse_modifier(const char *mod)
{
	for (size_t i = 0; i < sizeof(mod_names) / sizeof(mod_names[0]); i++) {
		if (strcmp(mod, mod_names[i].name) == 0) {
			return mod_names[i].mod;
		}
	}

	return 0;
}

/** Convert Lua table of modifier strings to bitmask
 * Stack: [..., modifiers_table]
 */
uint16_t
luaA_tomodifiers(lua_State *L, int ud)
{
	uint16_t modifiers = 0;


	luaL_checktype(L, ud, LUA_TTABLE);

	lua_pushnil(L);
	while (lua_next(L, ud < 0 ? ud - 1 : ud)) {
		if (lua_isstring(L, -1)) {
			const char *mod = lua_tostring(L, -1);
			modifiers |= parse_modifier(mod);
		}
		lua_pop(L, 1);
	}

	return modifiers;
}

/** Push modifier bitmask as Lua table of strings
 * \param L Lua state
 * \param modifiers Modifier bitmask
 * \return Number of values pushed (always 1)
 */
int
luaA_pushmodifiers(lua_State *L, uint16_t modifiers)
{
	int i, n = 0;

	lua_newtable(L);

	for (i = 0; i < (int)(sizeof(mod_names) / sizeof(mod_names[0])); i++) {
		if (mod_names[i].mod != 0xFFFF && (modifiers & mod_names[i].mod)) {
			lua_pushstring(L, mod_names[i].name);
			lua_rawseti(L, -2, ++n);
		}
	}

	return 1;
}

/** key_allocator - Allocate a new key object (class allocator pattern)
 * \param L Lua state
 * \return Newly allocated key object
 *
 * This is called by the class infrastructure. It should just allocate
 * the object. The __call metamethod will handle argument parsing.
 */
static lua_object_t *
key_allocator(lua_State *L)
{
	keyb_t *k;


	/* Create key object using LUA_OBJECT_FUNCS generated function */
	k = key_new(L);  /* This is generated by LUA_OBJECT_FUNCS macro */

	/* Initialize with defaults */
	k->modifiers = 0;
	k->keysym = XKB_KEY_NoSymbol;
	k->keycode = 0;


	/* Return the key object */
	return (lua_object_t *)k;
}

/** key.__call - Constructor metamethod for key class
 * \param L Lua state
 * \return Number of values pushed
 *
 * This handles the actual argument parsing when key{...} is called.
 */
static int
luaA_key_call(lua_State *L)
{
	keyb_t *k;
	const char *key_str;


	/* Stack: [class_table, args_table] */
	luaL_checktype(L, 2, LUA_TTABLE);

	/* Create key object via allocator */
	k = (keyb_t *)key_allocator(L);
	/* Now stack: [class_table, args_table, key_object] */

	/* Get modifiers (optional) */
	lua_getfield(L, 2, "modifiers");
	k->modifiers = lua_istable(L, -1) ? luaA_tomodifiers(L, -1) : 0;
	lua_pop(L, 1);


	/* Try keycode first (for bindings like #10) */
	lua_getfield(L, 2, "keycode");
	if (!lua_isnil(L, -1)) {
		k->keycode = lua_tointeger(L, -1);
		/* Convert keycode to keysym */
		/* Note: This requires xkb context, for now we'll use the keycode directly */
		k->keysym = k->keycode;
		lua_pop(L, 1);
		goto done;
	}
	lua_pop(L, 1);

	/* Get key string (required if no keycode) */
	lua_getfield(L, 2, "key");
	key_str = lua_tostring(L, -1);
	if (!key_str) {
		return luaL_error(L, "Key object requires 'key' or 'keycode' field");
	}


	/* Check for keycode syntax (#num) - AwesomeWM pattern */
	if (key_str[0] == '#') {
		k->keycode = atoi(key_str + 1);
		k->keysym = 0;  /* Keycode-only binding */
	}
	/* Single character - use ASCII/Unicode value directly as keysym (AwesomeWM pattern) */
	else if (strlen(key_str) == 1) {
		k->keysym = (xkb_keysym_t)key_str[0];
		k->keycode = 0;
	}
	/* Named keysym - use xkb_keysym_from_name */
	else {
		k->keysym = xkb_keysym_from_name(key_str, XKB_KEYSYM_CASE_INSENSITIVE);
		k->keycode = 0;

		if (k->keysym == XKB_KEY_NoSymbol) {
			return luaL_error(L, "Invalid keysym: %s", key_str);
		}
	}
	lua_pop(L, 1);

done:
	/* Key object is already on stack at position 3 */
	return 1;
}

/** key.modifiers property getter
 * \param L Lua state
 * \param key Key object
 * \return Number of values pushed
 */
static int
luaA_key_get_modifiers(lua_State *L, keyb_t *key)
{
	luaA_pushmodifiers(L, key->modifiers);
	return 1;
}

/** key.modifiers property setter
 * \param L Lua state
 * \param key Key object
 * \return 0
 */
static int
luaA_key_set_modifiers(lua_State *L, keyb_t *key)
{
	key->modifiers = luaA_tomodifiers(L, -1);
	luaA_object_emit_signal(L, -3, "property::modifiers", 0);
	return 0;
}

/** key.key property getter (returns keysym as string)
 * \param L Lua state
 * \param key Key object
 * \return Number of values pushed
 */
static int
luaA_key_get_key(lua_State *L, keyb_t *key)
{
	char keysym_name[64];
	xkb_keysym_get_name(key->keysym, keysym_name, sizeof(keysym_name));
	lua_pushstring(L, keysym_name);
	return 1;
}

/** key.keysym property getter (returns keysym as number)
 * \param L Lua state
 * \param key Key object
 * \return Number of values pushed
 */
static int
luaA_key_get_keysym(lua_State *L, keyb_t *key)
{
	lua_pushinteger(L, key->keysym);
	return 1;
}

/** Initialize key class
 * \param L Lua state
 */
void
key_class_setup(lua_State *L)
{
	static const struct luaL_Reg key_methods[] = {
		LUA_CLASS_METHODS(key)
		{ "__call", luaA_key_call },
		{ NULL, NULL }
	};

	static const struct luaL_Reg key_meta[] = {
		LUA_OBJECT_META(key)
		LUA_CLASS_META
		{ NULL, NULL }
	};


	luaA_class_setup(L, &key_class, "key", NULL,
	                 key_allocator,
	                 NULL, NULL,
	                 luaA_class_index_miss_property, luaA_class_newindex_miss_property,
	                 key_methods, key_meta);

	/* Fix __call: The class table needs __call in its metatable for key{...} to work.
	 * luaA_class_setup sets the class table as its own metatable, so we need to add
	 * __call directly to the class table. Use rawset to bypass __newindex. */
	lua_getglobal(L, "key");  /* Get the class table */
	lua_pushstring(L, "__call");  /* Push the key string */
	lua_pushcfunction(L, luaA_key_call);  /* Push the __call function */
	lua_rawset(L, -3);  /* class_table["__call"] = luaA_key_call (bypassing metatable) */

	/* Verify it was set */
	lua_pushstring(L, "__call");
	lua_rawget(L, -2);
	lua_pop(L, 1);  /* Pop __call */

	lua_pop(L, 1);  /* Pop class table */


	/* Add properties */
	luaA_class_add_property(&key_class, "modifiers",
	                        (lua_class_propfunc_t) luaA_key_set_modifiers,
	                        (lua_class_propfunc_t) luaA_key_get_modifiers,
	                        (lua_class_propfunc_t) luaA_key_set_modifiers);

	luaA_class_add_property(&key_class, "key",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_key_get_key,
	                        NULL);

	luaA_class_add_property(&key_class, "keysym",
	                        NULL,
	                        (lua_class_propfunc_t) luaA_key_get_keysym,
	                        NULL);

}

/* vim: filetype=c:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:textwidth=80
 */
